From bcd82df192a399bad563c98ec08f86678d346265 Mon Sep 17 00:00:00 2001
From: AfalpHy <736353503@qq.com>
Date: Tue, 18 Feb 2025 14:25:22 +0800
Subject: [PATCH 19/29] complete ps2

---
 perip/ps2/ps2_top_apb.v | 113 ++++++++++++++++++++++++++++++++++------
 1 file changed, 97 insertions(+), 16 deletions(-)

diff --git a/perip/ps2/ps2_top_apb.v b/perip/ps2/ps2_top_apb.v
index 080d38fa..08dd3c24 100644
--- a/perip/ps2/ps2_top_apb.v
+++ b/perip/ps2/ps2_top_apb.v
@@ -1,19 +1,100 @@
-module ps2_top_apb(
-  input         clock,
-  input         reset,
-  input  [31:0] in_paddr,
-  input         in_psel,
-  input         in_penable,
-  input  [2:0]  in_pprot,
-  input         in_pwrite,
-  input  [31:0] in_pwdata,
-  input  [3:0]  in_pstrb,
-  output        in_pready,
-  output [31:0] in_prdata,
-  output        in_pslverr,
-
-  input         ps2_clk,
-  input         ps2_data
+module ps2_top_apb (
+    input         clock,
+    input         reset,
+    input  [31:0] in_paddr,
+    input         in_psel,
+    input         in_penable,
+    input  [ 2:0] in_pprot,
+    input         in_pwrite,
+    input  [31:0] in_pwdata,
+    input  [ 3:0] in_pstrb,
+    output        in_pready,
+    output [31:0] in_prdata,
+    output        in_pslverr,
+
+    input ps2_clk,
+    input ps2_data
 );
 
+  reg [7:0] fifo[0:15];
+  reg [3:0] r_ptr, w_ptr;
+  reg [7:0] data;
+  reg [3:0] key_couter;
+
+  reg [9:0] buffer;  // ps2_data bits
+  reg [7:0] key_buffer[0:1];  // one key buffer
+  reg [1:0] key_len;
+  reg [3:0] count;  // count ps2_data bits
+  // detect falling edge of ps2_clk
+  reg [2:0] ps2_clk_sync;
+
+  wire sampling = ps2_clk_sync[2] & ~ps2_clk_sync[1];
+
+  assign in_pready = in_psel & in_penable;
+
+  assign in_prdata = {24'b0, data};
+
+  always @(posedge clock) begin
+    ps2_clk_sync <= {ps2_clk_sync[1:0], ps2_clk};
+  end
+
+  always @(posedge clock) begin
+    if (reset) begin
+      r_ptr <= 0;
+      w_ptr <= 0;
+      data <= 0;
+      key_couter <= 0;
+      buffer <= 0;
+      key_len <= 0;
+      count <= 0;
+      ps2_clk_sync <= 0;
+    end else begin
+      if (in_psel & ~in_penable) begin
+        if (~in_pwrite) begin
+          if (key_couter != 0) begin
+            data  <= fifo[r_ptr];
+            r_ptr <= r_ptr + 1;
+            if (fifo[r_ptr] != 'he0 && fifo[r_ptr] != 'hf0) key_couter <= key_couter - 1;
+          end else data <= 0;
+        end
+      end
+
+      if (sampling) begin
+        if (count == 4'd10) begin
+          if ((buffer[0] == 0) &&  // start bit
+              (ps2_data) &&  // stop bit
+              (^buffer[9:1])) begin  // odd  parity
+            if (buffer[8:1] == 'he0 || buffer[8:1] == 'hf0) begin
+              key_buffer[1] <= key_buffer[0];
+              key_buffer[0] <= buffer[8:1];
+              key_len <= key_len + 1;
+            end else begin
+              if (key_len == 2 && (w_ptr + 3 != r_ptr)) begin
+                fifo[w_ptr] <= key_buffer[1];
+                fifo[w_ptr+1] <= key_buffer[0];
+                fifo[w_ptr+2] <= buffer[8:1];
+                w_ptr <= w_ptr + 3;
+                key_couter <= key_couter + 1;
+              end else if (key_len == 1 && (w_ptr + 2 != r_ptr)) begin
+                fifo[w_ptr] <= key_buffer[0];
+                fifo[w_ptr+1] <= buffer[8:1];
+                w_ptr <= w_ptr + 2;
+                key_couter <= key_couter + 1;
+              end else if (key_len == 0 && (w_ptr + 1 != r_ptr)) begin
+                fifo[w_ptr] <= buffer[8:1];
+                w_ptr <= w_ptr + 1;
+                key_couter <= key_couter + 1;
+              end
+              key_len <= 0;
+            end
+          end
+          count <= 0;  // for next
+        end else begin
+          buffer[count] <= ps2_data;  // store ps2_data
+          count <= count + 1;
+        end
+      end
+    end
+  end
+
 endmodule
-- 
2.34.1

